###### 0. Load Functions for breeding simulation ######
source("scripts/function_scripts/1.0.function.simuProgeny.r")
source("scripts/function_scripts/2.0.function.clacProgeny.genVar.r")

###### 1. Breeding Simulation with cross and selection using UCPC ######
###' @param crsTbl [data.frame] nCross x 2(parents), cross table made from the initial population with IDs match the haplotype dat
###' @param haploArray [array] nMrk x nAlleles x 2(haplo), haplotype data including all cross parents
###' @param mrkEffLst [list] list of marker effects for nTrait, each list contains nMrk x nPops matrix
###' @param DLst [list] list of LD parameter at nGenTot
###' @param initPopInfoLst [list] list of GV mean and sd of the initial population
###' @param kappa [integer] for calculating representative value of progeny
###' @param nGenTot [integer] total number of generations
###' @param selGenNo [integer] number of generation of selection
###' @param nSelParent [integer] number of parents narrowed down to at selGenNo
###' @param nSelCrs [integer] number of crosses selected at selGenNo
###' @param nProgG0 [integer] number of progenies the initial cross pairs generate, default is 1 (for Homo x Homo)
###' @param nProgGSel [integer] number of progenies made at selGenNo generation
###' @param nProgGOther [integer] number of progenies the other generations generate
###' @param nCores [integer] number of cores for calculating progeny variance
###' @param saveDir [character] directory name to save genotype of each generation

BreedSimuUcTwoCrs <- function(crsTbl, haploArray, mrkEffLst, 
                              DLst, initPopInfoLst, 
                              kappa = qnorm(p = 0.975), 
                              nGenTot, selGenNo, nSelParent, nSelCrs, 
                              nProgG0, nProgGSel, nProgGOther = 1, 
                              nCores = 1, saveDir) {
  
  ###### Preparation ######
  ### parameters
  nCrs <- nrow(crsTbl)
  
  nTrait <- length(mrkEffLst)
  traitNames <- names(mrkEffLst)
  
  ### information about initial population
  initMeanVec <- initPopInfoLst$Mean[traitNames]
  initSdVec <- initPopInfoLst$Sd[traitNames]
  
  ###### breeding simulation ######
  for (genNo in 1:nGenTot) {
    
    if (genNo == 1) {
      
      ### first generation
      nParentNow <- nCrs ### number of parent of this generation
      nProgNow <- nProgG0 ### number of progeny generated by this generation
      nIndNow <- nParentNow * nProgG0 ### number of individuals in this generation
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nCrs, FUN = function(crsNo) {
        
        ### information of cross parents
        sireName <- crsTbl$sireID[crsNo]
        damName <- crsTbl$damID[crsNo]
        
        haploArrayP1 <- haploArray[, , sireName, ]
        haploArrayP2 <- haploArray[, , damName, ]
        
        gnOneCrsArray <- array(data = NA, 
                               dim = c(dim(haploArrayP1), nProgNow), 
                               dimnames = c(dimnames(haploArrayP1), 
                                            list(paste0("Progeny_", 1:nProgNow))))
        
        gnOneCrsArray[, , , 1:nProgNow] <- mate2Inds4Parents(haploArrayP1 = haploArrayP1, 
                                                             haploArrayP2 = haploArrayP2, 
                                                             nProg = nProgNow)
        
        return(gnOneCrsArray)
      })
      
    } else if (genNo == selGenNo) {
      
      ###############################################
      ### generation of selection and making cross
      nParentNow <- nSelCrs ### number of parent of this generation
      nProgNow <- nProgGSel ### number of progeny generated by this generation
      nIndNow <- nParentNow * nProgGSel ### number of individuals in this generation
      
      ### calculate GV
      gnGvAllTraitMat <- do.call(what = cbind, 
                                 args = lapply(X = 1:nTrait, 
                                               FUN = function(traitNo) {
                                                 ### gv of all progeny (1 trait)
                                                 gvOneTraitVec <- apply(X = gnAllIndHaploArray, MARGIN = 4, 
                                                                        FUN = function(eachHaploArray) {
                                                                          sum(eachHaploArray[, -1, 1] * mrkEffLst[[traitNo]]) + 
                                                                            sum(eachHaploArray[, -1, 2] * mrkEffLst[[traitNo]])
                                                                        })
                                                 
                                                 return(gvOneTraitVec)
                                               }))
      colnames(gnGvAllTraitMat) <- traitNames
      
      ### narrow down the number of parents by selection index (1:1)
      selIndexAllIndVec <- apply(X = gnGvAllTraitMat, MARGIN = 1, FUN = function(x) {
        sum((x - initMeanVec) / initSdVec)
      })
      selIndexSortedVec <- sort(selIndexAllIndVec, decreasing = TRUE)
      selIndName <- names(selIndexSortedVec)[1:nSelParent]
      
      ### generate cross tables
      crsTableNow <- expand.grid(rep(list(1:length(selIndName)), 2))
      crsTableNow <- crsTableNow[(crsTableNow[, 1] < crsTableNow[, 2]), ]
      crsTableNow <- do.call(what = rbind, 
                             args = apply(X = crsTableNow, MARGIN = 1, FUN = function(crsVec) {
                               crsVec[1] <- selIndName[as.numeric(crsVec[1])]
                               crsVec[2] <- selIndName[as.numeric(crsVec[2])]
                               return(c(crsVec[1], crsVec[2]))
                             }, simplify = FALSE))
      colnames(crsTableNow) <- c("sireID", "damID")
      
      ### calculate progeny variance to select parents
      progGvSelIndex <- 
        do.call(what = c, 
                args = pbmcapply::pbmclapply(X = 1:nrow(crsTableNow), FUN = function(crsNo) {
                  
                  crsP1NameNow <- crsTableNow[crsNo, 1]
                  crsP2NameNow <- crsTableNow[crsNo, 2]
                  
                  haploP1Now <- gnAllIndHaploArray[, -1, , crsP1NameNow]
                  haploP2Now <- gnAllIndHaploArray[, -1, , crsP2NameNow]
                  
                  ### progeny variance
                  progVarTwoTraitVec <- GenCovProgenyMultiPop(ObjectHaploP1 = haploP1Now, 
                                                              ObjectHaploP2 = haploP2Now, 
                                                              DLst = DLst, 
                                                              mrkEffLst = mrkEffLst)
                  
                  ### parent mean
                  parentMeanVec <- 
                    (((selIndexAllIndVec[crsP1NameNow] + selIndexAllIndVec[crsP2NameNow]) / 2) - initMeanVec) / initSdVec
                  ### progeny scaled variance
                  progScaledSdVec <- sqrt(progVarTwoTraitVec) / initSdVec
                  ### representative value of progeny (1:1 selection index)
                  progGvSelIndex <- sum(parentMeanVec + kappa * progScaledSdVec)
                  names(progGvSelIndex) <- crsNo
                  
                  return(progGvSelIndex)
                }, mc.cores = nCores))
      
      ### select parent based on progeny by selection index
      progGvSortedVec <- sort(progGvSelIndex, decreasing = TRUE)
      crsTblForNextGen <- 
        as.data.frame(crsTableNow[as.numeric(names(progGvSortedVec)[1:nSelCrs]), ])
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nCrs, FUN = function(crsNo) {
        
        ### information of cross parents
        sireName <- crsTblForNextGen$sireID[crsNo]
        damName <- crsTblForNextGen$damID[crsNo]
        
        haploArrayP1 <- gnAllIndHaploArray[, , , sireName]
        haploArrayP2 <- gnAllIndHaploArray[, , , damName]
        
        gnOneCrsArray <- array(data = NA, 
                               dim = c(dim(haploArrayP1), nProgNow), 
                               dimnames = c(dimnames(haploArrayP1), 
                                            list(paste0("Progeny_", 1:nProgNow))))
        
        gnOneCrsArray[, , , 1:nProgNow] <- mate2Inds4Parents(haploArrayP1 = haploArrayP1, 
                                                             haploArrayP2 = haploArrayP2, 
                                                             nProg = nProgNow)
        
        return(gnOneCrsArray)
      })
      ###############################################
      
    } else {
      
      ### other generation (selfing)
      nParentNow <- nIndNow
      nProgNow <- nProgGOther
      nIndNow <- nParentNow * nProgGOther
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nIndNow, FUN = function(indGnNo) {
        gnOneIndArray <- array(data = NA, 
                               dim = c(dim(haploArray)[c(1, 2, 4)], nProgNow), 
                               dimnames = c(dimnames(haploArray)[c(1, 2, 4)], 
                                            list(paste0("Progeny_", 1:nProgNow))))
        ### selfing of 1 individual in the previous generation
        gnOneIndArray[, , , 1:nProgNow] <- 
          selfing4Parents(haploArray = gnAllIndHaploArray[, , , indGnNo], 
                          nProg = nProgNow)
        
        return(gnOneIndArray)
      })
    }
    
    ### common to all the genrations
    gnAllIndHaploArray <- do.call(what = abind::abind, args = gnHaploLst)
    dimnames(gnAllIndHaploArray)[[4]] <- paste0("G", genNo, "_", 
                                                rep(1:nParentNow, each = nProgNow), 
                                                "_", rep(1:nProgNow, nParentNow))
    ### genotype (save for each generation)
    gnAllIndGenoArray <- gnAllIndHaploArray[, , 1, ] + gnAllIndHaploArray[, , 2, ]
    
    ### save
    fileNameGenoArrayNow <- paste0(saveDir, "genoArray_G", genNo, ".rds")
    saveRDS(object = gnAllIndGenoArray, file = fileNameGenoArrayNow)
  }

  gc(reset = TRUE);gc(reset = TRUE)
  
  return(NULL)
}




###### 2. Breeding Simulation with cross and selection ######
###' @param crsTbl [data.frame] nCross x 2(parents), cross table made from the initial population with IDs match the haplotype dat
###' @param haploArray [array] nMrk x nAlleles x 2(haplo), haplotype data including all cross parents
###' @param mrkEffLst [list] list of marker effects for nTrait, each list contains nMrk x nPops matrix
###' @param initPopInfoLst [list] list of GV mean and sd of the initial population
###' @param nGenTot [integer] total number of generations
###' @param selGenNo [integer] number of generation of selection
###' @param nSelInd [integer] number of individuals selected at selGenNo
###' @param nProgG0 [integer] number of progenies the initial cross pairs generate, default is 1 (for Homo x Homo)
###' @param nProgGSel [integer] number of progenies made at selGenNo generation
###' @param nProgGOther [integer] number of progenies the other generations generate
###' @param saveDir [character] directory name to save genotype of each generation

BreedSimuTwoCrs <- function(crsTbl, haploArray, mrkEffLst, initPopInfoLst, nGenTot, 
                            selGenNo, nSelInd, nProgG0, nProgGSel, nProgGOther = 1, 
                            saveDir) {
  
  ###### Preparation ######
  ### parameters
  nCrs <- nrow(crsTbl)
  
  nTrait <- length(mrkEffLst)
  traitNames <- names(mrkEffLst)
  
  ### information about initial population
  initMeanVec <- initPopInfoLst$Mean[traitNames]
  initSdVec <- initPopInfoLst$Sd[traitNames]
  
  ###### breeding simulation ######
  for (genNo in 1:nGenTot) {
    
    if (genNo == 1) {
      
      ### first generation
      nParentNow <- nCrs ### number of parent of this generation
      nProgNow <- nProgG0 ### number of progeny generated by this generation
      nIndNow <- nParentNow * nProgG0 ### number of individuals in this generation
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nCrs, FUN = function(crsNo) {
        
        ### information of cross parents
        sireName <- crsTbl$sireID[crsNo]
        damName <- crsTbl$damID[crsNo]
        
        haploArrayP1 <- haploArray[, , sireName, ]
        haploArrayP2 <- haploArray[, , damName, ]
        
        gnOneCrsArray <- array(data = NA, 
                               dim = c(dim(haploArrayP1), nProgNow), 
                               dimnames = c(dimnames(haploArrayP1), 
                                            list(paste0("Progeny_", 1:nProgNow))))
        
        gnOneCrsArray[, , , 1:nProgNow] <- mate2Inds4Parents(haploArrayP1 = haploArrayP1, 
                                                             haploArrayP2 = haploArrayP2, 
                                                             nProg = nProgNow)
        
        return(gnOneCrsArray)
      })
      
    } else if (genNo == selGenNo) {
      
      ###############################################
      ### generation of selection and making cross
      nParentNow <- choose(n = nSelInd, k = 2) ### number of parent of this generation
      nProgNow <- nProgGSel ### number of progeny generated by this generation
      nIndNow <- nParentNow * nProgGSel ### number of individuals in this generation
      
      ### calculate GV
      gnGvAllTraitMat <- do.call(what = cbind, 
                                 args = lapply(X = 1:nTrait, 
                                               FUN = function(traitNo) {
                                                 ### gv of all progeny (1 trait)
                                                 gvOneTraitVec <- apply(X = gnAllIndHaploArray, MARGIN = 4, 
                                                                        FUN = function(eachHaploArray) {
                                                                          sum(eachHaploArray[, -1, 1] * mrkEffLst[[traitNo]]) + 
                                                                            sum(eachHaploArray[, -1, 2] * mrkEffLst[[traitNo]])
                                                                        })
                                                 
                                                 return(gvOneTraitVec)
                                               }))
      colnames(gnGvAllTraitMat) <- traitNames
      
      ### select parents by selection index (1:1)
      selIndexAllIndVec <- apply(X = gnGvAllTraitMat, MARGIN = 1, FUN = function(x) {
        sum((x - initMeanVec) / initSdVec)
      })
      selIndexSortedVec <- sort(selIndexAllIndVec, decreasing = TRUE)
      selIndName <- names(selIndexSortedVec)[1:nSelParent]
      
      ### generate cross tables
      crsTableNow <- expand.grid(rep(list(1:length(selIndName)), 2))
      crsTableNow <- crsTableNow[(crsTableNow[, 1] < crsTableNow[, 2]), ]
      crsTableNow <- as.data.frame(do.call(what = rbind, 
                                           args = apply(X = crsTableNow, MARGIN = 1, FUN = function(crsVec) {
                                             crsVec[1] <- selIndName[as.numeric(crsVec[1])]
                                             crsVec[2] <- selIndName[as.numeric(crsVec[2])]
                                             return(c(crsVec[1], crsVec[2]))
                                           }, simplify = FALSE)))
      colnames(crsTableNow) <- c("sireID", "damID")
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nCrs, FUN = function(crsNo) {
        
        ### information of cross parents
        sireName <- crsTableNow$sireID[crsNo]
        damName <- crsTableNow$damID[crsNo]
        
        haploArrayP1 <- gnAllIndHaploArray[, , , sireName]
        haploArrayP2 <- gnAllIndHaploArray[, , , damName]
        
        gnOneCrsArray <- array(data = NA, 
                               dim = c(dim(haploArrayP1), nProgNow), 
                               dimnames = c(dimnames(haploArrayP1), 
                                            list(paste0("Progeny_", 1:nProgNow))))
        
        gnOneCrsArray[, , , 1:nProgNow] <- mate2Inds4Parents(haploArrayP1 = haploArrayP1, 
                                                             haploArrayP2 = haploArrayP2, 
                                                             nProg = nProgNow)
        
        return(gnOneCrsArray)
      })
      ###############################################
      
    } else {
      
      ### other generation (selfing)
      nParentNow <- nIndNow
      nProgNow <- nProgGOther
      nIndNow <- nParentNow * nProgGOther
      
      ### generate progeny
      gnHaploLst <- lapply(X = 1:nIndNow, FUN = function(indGnNo) {
        gnOneIndArray <- array(data = NA, 
                               dim = c(dim(haploArray)[c(1, 2, 4)], nProgNow), 
                               dimnames = c(dimnames(haploArray)[c(1, 2, 4)], 
                                            list(paste0("Progeny_", 1:nProgNow))))
        ### selfing of 1 individual in the previous generation
        gnOneIndArray[, , , 1:nProgNow] <- 
          selfing4Parents(haploArray = gnAllIndHaploArray[, , , indGnNo], 
                          nProg = nProgNow)
        
        return(gnOneIndArray)
      })
    }
    
    ### common to all the genrations
    gnAllIndHaploArray <- do.call(what = abind::abind, args = gnHaploLst)
    dimnames(gnAllIndHaploArray)[[4]] <- paste0("G", genNo, "_", 
                                                rep(1:nParentNow, each = nProgNow), 
                                                "_", rep(1:nProgNow, nParentNow))
    
    ### genotype (save for each generation)
    gnAllIndGenoArray <- gnAllIndHaploArray[, , 1, ] + gnAllIndHaploArray[, , 2, ]
    
    ### save
    fileNameGenoArrayNow <- paste0(saveDir, "genoArray_G", genNo, ".rds")
    saveRDS(object = gnAllIndGenoArray, file = fileNameGenoArrayNow)
    
  }
  gc(reset = TRUE);gc(reset = TRUE)
  
  return(NULL)
}